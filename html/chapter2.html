<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>第二章 智能体发展史 - Hello Agents 2025</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    fontFamily: {
                        'sans': ['Inter', 'system-ui', 'sans-serif'],
                    },
                    colors: {
                        primary: {
                            50: '#f0f9ff',
                            100: '#e0f2fe',
                            500: '#0ea5e9',
                            600: '#0284c7',
                            700: '#0369a1',
                        }
                    }
                }
            }
        }
    </script>
    <style>
        /* 自定义样式 */
        .gradient-bg {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        
        .glass-effect {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .text-gradient {
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        /* 深色模式样式 */
        .dark {
            background-color: #0f172a;
            color: #e2e8f0;
        }
        
        .dark .bg-white {
            background-color: #1e293b;
        }
        
        .dark .text-gray-800 {
            color: #e2e8f0;
        }
        
        .dark .text-gray-600 {
            color: #94a3b8;
        }
        
        .dark .border-gray-200 {
            border-color: #334155;
        }
        
        .dark .shadow-lg {
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.3), 0 4px 6px -2px rgba(0, 0, 0, 0.2);
        }

        .prose-custom {
            line-height: 1.75;
            max-width: none;
            color: #374151;
        }
        .dark .prose-custom {
            color: #e5e7eb;
        }
        .prose-custom h1 {
            font-size: 2.5rem;
            font-weight: 800;
            line-height: 1.2;
            margin-bottom: 1rem;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .prose-custom h2 {
            font-size: 2rem;
            font-weight: 700;
            line-height: 1.3;
            margin: 2.5rem 0 1.5rem 0;
            color: #1f2937;
            border-bottom: 2px solid #e5e7eb;
            padding-bottom: 0.5rem;
        }
        .dark .prose-custom h2 {
            color: #f9fafb;
            border-color: #374151;
        }
        .prose-custom h3 {
            font-size: 1.5rem;
            font-weight: 600;
            line-height: 1.4;
            margin: 2rem 0 1rem 0;
            color: #374151;
        }
        .dark .prose-custom h3 {
            color: #e5e7eb;
        }
        .prose-custom h4 {
            font-size: 1.25rem;
            font-weight: 600;
            line-height: 1.4;
            margin: 1.5rem 0 0.75rem 0;
            color: #4b5563;
        }
        .dark .prose-custom h4 {
            color: #d1d5db;
        }
        .code-block {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 0.75rem;
            padding: 1.5rem;
            margin: 1.5rem 0;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.875rem;
            line-height: 1.6;
            overflow-x: auto;
        }
        .dark .code-block {
            background: #1e293b;
            border-color: #334155;
            color: #e2e8f0;
        }
        .image-container {
            margin: 2rem 0;
            text-align: center;
        }
        .image-container img {
            max-width: 100%;
            height: auto;
            border-radius: 0.75rem;
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        .image-container img:hover {
            transform: scale(1.02);
            box-shadow: 0 20px 40px -10px rgba(0, 0, 0, 0.15);
        }
        .image-caption {
            margin-top: 1rem;
            font-size: 0.875rem;
            color: #6b7280;
            font-style: italic;
        }
        .dark .image-caption {
            color: #9ca3af;
        }
        .table-container {
            margin: 2rem 0;
            overflow-x: auto;
            border-radius: 0.75rem;
            border: 1px solid #e5e7eb;
        }
        .dark .table-container {
            border-color: #374151;
        }
        .table-container table {
            width: 100%;
            border-collapse: collapse;
        }
        .table-container th,
        .table-container td {
            padding: 1rem;
            text-align: left;
            border-bottom: 1px solid #e5e7eb;
        }
        .dark .table-container th,
        .dark .table-container td {
            border-color: #374151;
        }
        .table-container th {
            background: #f9fafb;
            font-weight: 600;
            color: #374151;
        }
        .dark .table-container th {
            background: #1f2937;
            color: #f9fafb;
        }
        .fade-in {
            animation: fadeIn 0.6s ease-in-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .hover-lift {
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        .hover-lift:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1);
        }
        
        /* 滚动条样式 */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }
        .dark ::-webkit-scrollbar-track {
            background: #374151;
        }
        ::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #a8a8a8;
        }
        .dark ::-webkit-scrollbar-thumb {
            background: #6b7280;
        }
        .dark ::-webkit-scrollbar-thumb:hover {
            background: #9ca3af;
        }
        
        /* 返回顶部按钮 */
        .back-to-top {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            width: 3rem;
            height: 3rem;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }
        .back-to-top.show {
            opacity: 1;
            visibility: visible;
        }
        .back-to-top:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2);
        }
        
        /* 引用块样式 */
        .quote-block {
            background: #f8fafc;
            border-left: 4px solid #667eea;
            border-radius: 0.5rem;
            padding: 1.5rem;
            margin: 1.5rem 0;
            font-style: italic;
            position: relative;
        }
        .dark .quote-block {
            background: #1e293b;
            border-color: #764ba2;
        }
        .quote-block::before {
            content: '"';
            font-size: 4rem;
            color: #667eea;
            position: absolute;
            top: -0.5rem;
            left: 1rem;
            line-height: 1;
        }
        
        /* 强调文本样式 */
        .highlight-text {
            background: linear-gradient(135deg, #667eea20, #764ba220);
            padding: 0.2rem 0.5rem;
            border-radius: 0.25rem;
            font-weight: 600;
        }
        
        /* 时间线样式 */
        .timeline {
            position: relative;
            padding-left: 2rem;
            margin: 2rem 0;
        }
        .timeline::before {
            content: '';
            position: absolute;
            left: 0.5rem;
            top: 0;
            bottom: 0;
            width: 2px;
            background: linear-gradient(135deg, #667eea, #764ba2);
        }
        .timeline-item {
            position: relative;
            margin-bottom: 2rem;
            padding-left: 2rem;
        }
        .timeline-item::before {
            content: '';
            position: absolute;
            left: -0.5rem;
            top: 0.5rem;
            width: 1rem;
            height: 1rem;
            background: #667eea;
            border-radius: 50%;
            border: 3px solid white;
            box-shadow: 0 0 0 3px #667eea20;
        }
        .dark .timeline-item::before {
            border-color: #1e293b;
        }
    </style>
</head>
<body class="bg-white dark:bg-gray-900 text-gray-900 dark:text-gray-100 font-sans transition-colors duration-300">
    <!-- 导航栏 -->
    <nav class="bg-white dark:bg-gray-800 shadow-sm border-b border-gray-200 dark:border-gray-700 sticky top-0 z-50">
        <div class="max-w-7xl mx-auto px-6 py-4">
            <div class="flex items-center justify-between">
                <div class="flex items-center space-x-4">
                    <i class="fas fa-robot text-2xl text-gradient"></i>
                    <h1 class="text-xl font-bold text-gradient">Hello-Agents</h1>
                </div>
                <div class="flex items-center space-x-4">
                    <button id="theme-toggle" class="p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors">
                        <i class="fas fa-moon dark:fa-sun text-gray-600 dark:text-gray-300"></i>
                    </button>
                </div>
            </div>
        </div>
    </nav>

    <!-- 返回顶部按钮 -->
    <button class="back-to-top" id="backToTop" title="返回顶部">
        <i class="fas fa-arrow-up"></i>
    </button>

    <!-- 主要内容 -->
    <main class="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        <article class="prose-custom fade-in">
            <!-- 章节标题 -->
            <header class="mb-12 text-center">
                <h1 class="mb-4">第二章 智能体发展史</h1>
                <p class="text-lg text-gray-600 dark:text-gray-300 max-w-3xl mx-auto">
                    从符号主义的理性探索到现代大语言模型的涌现智能，智能体的发展历程见证了人工智能领域的思想变革与技术突破。
                </p>
            </header>

            <!-- 引言 -->
            <section id="introduction" class="mb-12">
                <p class="text-lg leading-relaxed mb-6">
                    在第一章中，我们初步认识了智能体的基本概念和核心组件。然而，要真正理解现代智能体的设计理念和技术架构，我们需要回溯历史，探寻其思想根源和演进脉络。
                </p>
                <p class="text-lg leading-relaxed mb-8">
                    智能体的发展史，实际上就是人工智能领域对"智能"本质认知不断深化的历程。从早期符号主义试图用逻辑规则模拟人类推理，到联结主义通过神经网络学习模式识别，再到现代大语言模型展现的涌现智能——每一次范式转换都深刻影响着智能体的设计思路。
                </p>
                <div class="quote-block">
                    本章将带你穿越时空，见证智能体从概念萌芽到技术成熟的完整历程，理解不同时代的技术选择背后的深层逻辑，为掌握现代智能体技术奠定坚实的历史基础。
                </div>
                
                <div class="image-container">
                    <img src="../docs/images/2-figures/1757246501849-00.png" alt="AI智能体的演进阶梯" />
                    <p class="image-caption">图 2.1 AI智能体的演进阶梯</p>
                </div>
                
                <p class="mb-6">
                    如图2.1所示，<strong>每一个新范式的出现，都是为了解决上一代范式的核心"痛点"或根本局限。</strong> 而新的解决方案在带来能力飞跃的同时，也引入了新的、在当时难以克服的"局限"，而这又为下一代范式的诞生埋下了伏笔。理解这一"问题驱动"的迭代历程，能帮助我们更深刻地把握现代智能体技术选型背后的深层原因与历史必然性。
                </p>
            </section>

            <!-- 2.1 符号主义的探索与局限 -->
            <section id="symbolic-ai" class="mb-12">
                <h2>2.1 符号主义的探索与局限</h2>
                <p class="mb-6">
                    人工智能的历史始于一个雄心勃勃的设想：如果人类的智能本质上是对符号的操作和逻辑推理，那么我们是否可以通过编程让计算机模拟这一过程，从而实现机器智能？这一思想流派被称为<span class="highlight-text">符号主义（Symbolism）</span>，它主导了人工智能研究的前几十年。
                </p>
                <p class="mb-6">
                    符号主义的核心假设可以概括为<strong>"物理符号系统假设"</strong>：智能行为的必要和充分条件是能够操作物理符号系统。换句话说，智能就是符号操作，而符号操作就能产生智能。基于这一假设，早期的AI研究者们开始构建各种基于符号推理的系统，试图让机器像人类一样"思考"。
                </p>
                
                <div class="image-container">
                    <img src="../docs/images/2-figures/1757246501849-0.png" alt="符号主义AI的核心理念" />
                    <p class="image-caption">图 2.2 符号主义AI的核心理念：通过符号操作实现智能</p>
                </div>

                <!-- 2.1.1 专家系统的兴起 -->
                <section id="expert-systems" class="mb-10">
                    <h3>2.1.1 专家系统的兴起</h3>
                    <p class="mb-6">
                        20世纪70年代，符号主义的第一个重大成功来自<span class="highlight-text">专家系统（Expert Systems）</span>。这类系统试图将特定领域专家的知识和推理过程编码成计算机程序，使机器能够在该领域内做出专家级别的判断和决策。
                    </p>
                    <p class="mb-6">
                        最著名的早期专家系统是<strong>MYCIN</strong>，由斯坦福大学在1970年代开发，用于诊断血液感染疾病并推荐抗生素治疗方案。MYCIN的核心架构包含三个关键组件：
                    </p>
                    <ul class="list-disc pl-6 mb-6 space-y-2">
                        <li><strong>知识库（Knowledge Base）</strong>：包含约600条医学规则，每条规则都以"IF-THEN"的形式表达医学知识</li>
                        <li><strong>推理引擎（Inference Engine）</strong>：负责根据当前症状和检测结果，在知识库中搜索匹配的规则并进行逻辑推理</li>
                        <li><strong>解释系统（Explanation System）</strong>：能够向用户解释系统的推理过程和结论依据</li>
                    </ul>
                    <p class="mb-6">
                        MYCIN的一个典型规则示例如下：
                    </p>
                    <div class="code-block">
                        <pre><code>IF: 
    1) 感染部位是血液
    2) 患者年龄大于10岁
    3) 细菌培养结果为革兰氏阳性球菌
    4) 细菌形态为链状排列
THEN: 
    病原体很可能是链球菌 (置信度: 0.8)</code></pre>
                    </div>
                    <p class="mb-6">
                        令人印象深刻的是，MYCIN在诊断准确性上达到了与人类专家相当的水平，在某些测试中甚至超过了一般医生的表现。这一成功极大地鼓舞了AI研究界，专家系统迅速扩展到其他领域，如地质勘探、化学分析、工程设计等。
                    </p>
                </section>

                <!-- 2.1.2 SHRDLU：理解与行动的先驱 -->
                <section id="shrdlu" class="mb-10">
                    <h3>2.1.2 SHRDLU：理解与行动的先驱</h3>
                    <p class="mb-6">
                        如果说MYCIN展示了符号主义在知识推理方面的潜力，那么<strong>SHRDLU</strong>则展现了其在自然语言理解和行动规划方面的可能性。SHRDLU由MIT的Terry Winograd在1970年开发，是一个能够理解自然语言指令并在虚拟积木世界中执行操作的程序。
                    </p>
                    <div class="image-container">
                        <img src="../docs/images/2-figures/1757246501849-1.png" alt="SHRDLU系统界面" />
                        <p class="image-caption">图 2.1 SHRDLU系统的积木世界界面</p>
                    </div>
                    <p class="mb-6">
                        SHRDLU的工作环境是一个简化的三维积木世界，包含不同颜色、形状和大小的积木。用户可以用自然语言与系统对话，要求它移动积木、回答问题或解释行为。以下是一个典型的人机对话示例：
                    </p>
                    <div class="code-block">
                        <pre><code>用户: 把红色的金字塔放在蓝色的方块上
SHRDLU: 好的 (执行动作)

用户: 现在把它放在绿色方块旁边
SHRDLU: 好的 (执行动作)

用户: 什么支撑着绿色的金字塔？
SHRDLU: 蓝色的方块

用户: 有多少个方块不在盒子里？
SHRDLU: 四个</code></pre>
                    </div>
                    <p class="mb-6">
                        SHRDLU的成功在于它实现了多个AI子领域的集成：
                    </p>
                    <ul class="list-disc pl-6 mb-6 space-y-2">
                        <li><strong>自然语言解析</strong>：将英语句子转换为内部的符号表示</li>
                        <li><strong>语义理解</strong>：理解指代关系（如"它"指向什么对象）和空间关系</li>
                        <li><strong>规划与执行</strong>：将高层目标分解为具体的动作序列</li>
                        <li><strong>世界建模</strong>：维护对积木世界当前状态的完整表示</li>
                    </ul>
                    <p class="mb-6">
                        然而，SHRDLU的成功也暴露了符号主义方法的一个根本性限制：它只能在一个极度简化、完全可控的"玩具世界"中工作。一旦脱离这个封闭的积木环境，系统就完全无法应对真实世界的复杂性和不确定性。
                    </p>
                </section>

                <!-- 2.1.3 符号主义面临的挑战 -->
                <section id="symbolic-challenges" class="mb-10">
                    <h3>2.1.3 符号主义面临的挑战</h3>
                    <p class="mb-6">
                        尽管专家系统和SHRDLU等早期成功案例展现了符号主义的潜力，但随着研究的深入，这一范式面临的根本性挑战逐渐显现：
                    </p>

                    <h4 class="text-lg font-semibold mb-4 text-gray-700 dark:text-gray-300">知识获取瓶颈</h4>
                    <p class="mb-6">
                        构建一个有效的专家系统需要将领域专家的知识完全显式化并编码为规则。然而，人类专家的很多知识是<span class="highlight-text">隐性的（Tacit Knowledge）</span>——他们知道如何做，但很难准确描述自己是如何做的。例如，一个经验丰富的医生在诊断时会综合考虑患者的神态、语调、体态等微妙信息，但这些"直觉"很难转化为明确的IF-THEN规则。
                    </p>

                    <h4 class="text-lg font-semibold mb-4 text-gray-700 dark:text-gray-300">常识推理的困难</h4>
                    <p class="mb-6">
                        人类的智能很大程度上依赖于对世界的<span class="highlight-text">常识性理解</span>。我们知道水往低处流、物体不能同时出现在两个地方、人需要呼吸才能生存等基本事实。然而，要将这些看似简单的常识编码为逻辑规则却异常困难。道格拉斯·莱纳特（Douglas Lenat）领导的Cyc项目试图构建一个包含人类常识的庞大知识库，经过几十年的努力，仍然远未达到预期目标。
                    </p>

                    <h4 class="text-lg font-semibold mb-4 text-gray-700 dark:text-gray-300">框架问题</h4>
                    <p class="mb-6">
                        在动态环境中，智能体需要推理哪些事实在行动后保持不变，哪些会发生改变。这被称为<span class="highlight-text">框架问题（Frame Problem）</span>。例如，当机器人移动一个杯子时，杯子的位置改变了，但杯子的颜色、房间里其他物体的位置、今天的日期等成千上万的事实都保持不变。如何有效地表示和推理这种"默认不变性"成为符号主义系统的重大挑战。
                    </p>

                    <h4 class="text-lg font-semibold mb-4 text-gray-700 dark:text-gray-300">组合爆炸</h4>
                    <p class="mb-6">
                        随着问题规模的增长，可能的状态空间和推理路径呈指数级增长，导致<span class="highlight-text">组合爆炸</span>。即使是相对简单的问题，穷举所有可能的推理路径也可能需要天文数字般的计算时间。
                    </p>

                    <p class="mb-6">
                        这些挑战的根源在于符号主义的一个基本假设：智能可以通过操作抽象符号来实现，而无需考虑这些符号与真实世界的具体联系。然而，真实世界的复杂性、模糊性和动态性远超出了纯符号系统所能处理的范围。正是在这种背景下，研究者们开始探索其他的智能实现路径。
                    </p>
                    
                    <div class="image-container">
                        <img src="../docs/images/2-figures/1757246501849-2.png" alt="符号主义面临的核心挑战" />
                        <p class="image-caption">图 2.3 符号主义面临的核心挑战</p>
                    </div>
                </section>
            </section>

            <!-- 2.2 ELIZA：规则驱动的对话系统 -->
            <section id="eliza" class="mb-12">
                <h2>2.2 ELIZA：规则驱动的对话系统</h2>
                <p class="mb-6">
                    在符号主义的探索历程中，有一个系统虽然简单，却产生了深远的影响——<strong>ELIZA</strong>。这个由MIT的约瑟夫·魏岑鲍姆（Joseph Weizenbaum）在1966年开发的程序，是最早的聊天机器人之一，它通过简单的模式匹配和文本替换技术，模拟心理治疗师与患者的对话。
                </p>
                <p class="mb-6">
                    ELIZA的意义不仅在于它展示了早期自然语言处理的可能性，更重要的是，它揭示了符号主义方法的本质特征和根本局限。通过深入分析ELIZA的工作机制并亲手实现一个简化版本，我们可以直观地理解规则驱动系统的能力边界。
                </p>

                <!-- 2.2.1 ELIZA的工作机制 -->
                <section id="eliza-mechanism" class="mb-10">
                    <h3>2.2.1 ELIZA的工作机制</h3>
                    <p class="mb-6">
                        ELIZA的核心思想极其简单：通过<span class="highlight-text">模式匹配（Pattern Matching）</span>识别用户输入中的关键词或短语，然后根据预定义的规则生成相应的回复。整个系统基于以下几个关键组件：
                    </p>

                    <h4 class="text-lg font-semibold mb-4 text-gray-700 dark:text-gray-300">模式-响应规则库</h4>
                    <p class="mb-6">
                        ELIZA的"智能"完全来源于一套精心设计的模式-响应规则。每条规则包含一个输入模式和一组可能的响应模板。例如：
                    </p>
                    <div class="code-block">
                        <pre><code>模式: "我感到 (.*)"
响应模板: 
- "你为什么感到 {1}？"
- "感到 {1} 让你想到了什么？"
- "你经常感到 {1} 吗？"

模式: "我的 (.*) 让我 (.*)"
响应模板:
- "告诉我更多关于你的 {1} 的事情"
- "你的 {1} 如何让你 {2}？"</code></pre>
                    </div>

                    <h4 class="text-lg font-semibold mb-4 text-gray-700 dark:text-gray-300">代词转换机制</h4>
                    <p class="mb-6">
                        为了维持对话的自然性，ELIZA会自动转换人称代词。当用户说"我很困惑"时，系统会将其转换为"你很困惑"来构造回复。这种简单的语法变换给用户造成了系统"理解"对话内容的错觉。
                    </p>

                    <h4 class="text-lg font-semibold mb-4 text-gray-700 dark:text-gray-300">关键词优先级</h4>
                    <p class="mb-6">
                        不同的关键词被赋予不同的优先级。例如，"母亲"、"父亲"等家庭关系词汇通常具有较高优先级，因为它们在心理治疗对话中往往更重要。
                    </p>

                    <h4 class="text-lg font-semibold mb-4 text-gray-700 dark:text-gray-300">通用回退机制</h4>
                    <p class="mb-6">
                        当输入无法匹配任何特定模式时，系统会使用通用的回退响应，如"请继续说下去"、"这很有趣，告诉我更多"等，以维持对话的连续性。
                    </p>

                    <p class="mb-6">
                        以下是一个典型的ELIZA对话示例：
                    </p>
                    <div class="code-block">
                        <pre><code>用户: 我感到很沮丧
ELIZA: 你为什么感到沮丧？

用户: 我的工作让我很焦虑
ELIZA: 告诉我更多关于你的工作的事情

用户: 我觉得我无法胜任
ELIZA: 你为什么觉得你无法胜任？

用户: 我的老板总是批评我
ELIZA: 你的老板如何影响你？</code></pre>
                    </div>
                    
                    <div class="image-container">
                        <img src="../docs/images/2-figures/1757246501849-3.png" alt="ELIZA的工作流程" />
                        <p class="image-caption">图 2.4 ELIZA的工作流程：从模式匹配到响应生成</p>
                    </div>
                </section>

                <!-- 2.2.2 构建一个简化版ELIZA -->
                <section id="eliza-implementation" class="mb-10">
                    <h3>2.2.2 构建一个简化版ELIZA</h3>
                    <p class="mb-6">
                        为了深入理解ELIZA的工作原理，让我们动手实现一个简化版本。这个实践将帮助我们直观地感受规则驱动系统的能力与局限。
                    </p>

                    <div class="code-block">
                        <pre><code>import re
import random

# 定义模式-响应规则库
rules = {
    r'我需要 (.*)': [
        "你为什么需要 {}？",
        "拥有 {} 对你来说有多重要？",
        "如果你得到了 {}，会发生什么？"
    ],
    r'我感到 (.*)': [
        "你为什么感到 {}？",
        "感到 {} 让你想到了什么？",
        "你经常感到 {} 吗？",
        "当你感到 {} 时，你会做什么？"
    ],
    r'我是 (.*)': [
        "你为什么说你是 {}？",
        "你喜欢成为 {} 吗？",
        "你认为成为 {} 意味着什么？"
    ],
    r'我的 (.*) 是 (.*)': [
        "告诉我更多关于你的 {} 的事情",
        "你的 {} 为什么是 {}？",
        "你对你的 {} 感觉如何？"
    ],
    r'我想 (.*)': [
        "你为什么想 {}？",
        "如果你 {}，会怎么样？",
        "你真的想 {} 吗？"
    ],
    r'我记得 (.*)': [
        "你经常想起 {} 吗？",
        "除了 {}，你还记得什么？",
        "为什么你现在想到了 {}？"
    ],
    r'我的母亲 (.*)': [
        "告诉我更多关于你母亲的事情",
        "你和你母亲的关系如何？",
        "你母亲如何影响你？"
    ],
    r'我的父亲 (.*)': [
        "你的父亲在你生活中扮演什么角色？",
        "告诉我更多关于你父亲的事情",
        "你和你父亲相处得怎么样？"
    ],
    r'(.*)？': [
        "你为什么问这个问题？",
        "这个问题对你来说重要吗？",
        "你觉得答案是什么？",
        "你为什么想知道这个？"
    ],
    r'.*': [  # 通配符规则，匹配任何输入
        "请继续说下去",
        "这很有趣，告诉我更多",
        "我明白了，然后呢？",
        "你能详细说说吗？",
        "这让你有什么感受？"
    ]
}

# 代词转换字典
pronoun_swap = {
    "我": "你", "你": "我", "我的": "你的", "你的": "我的",
    "我是": "你是", "你是": "我是", "我会": "你会", "你会": "我会",
    "我有": "你有", "你有": "我有", "我想": "你想", "你想": "我想",
    "我觉得": "你觉得", "你觉得": "我觉得", "我们": "你们", "你们": "我们",
    "i": "you", "you": "i", "my": "your", "your": "my",
    "i'm": "you are", "you're": "i am", "i've": "you have", 
    "you've": "i have", "i'll": "you will", "you'll": "i will",
    "i've": "you have", "i'll": "you will", "yours": "mine",
    "mine": "yours"
}

def swap_pronouns(phrase):
    """
    对输入短语中的代词进行第一/第二人称转换
    """
    words = phrase.lower().split()
    swapped_words = [pronoun_swap.get(word, word) for word in words]
    return " ".join(swapped_words)

def respond(user_input):
    """
    根据规则库生成响应
    """
    for pattern, responses in rules.items():
        match = re.search(pattern, user_input, re.IGNORECASE)
        if match:
            # 捕获匹配到的部分
            captured_group = match.group(1) if match.groups() else ''
            # 进行代词转换
            swapped_group = swap_pronouns(captured_group)
            # 从模板中随机选择一个并格式化
            response = random.choice(responses).format(swapped_group)
            return response
    # 如果没有匹配任何特定规则，使用最后的通配符规则
    return random.choice(rules[r'.*'])

# 主聊天循环
if __name__ == '__main__':
    print("Therapist: Hello! How can I help you today?")
    while True:
        user_input = input("You: ")
        if user_input.lower() in ["quit", "exit", "bye"]:
            print("Therapist: Goodbye. It was nice talking to you.")
            break
        response = respond(user_input)
        print(f"Therapist: {response}")</code></pre>
                    </div>

                    <p class="mb-6">运行示例：</p>
                    <div class="code-block">
                        <pre><code>Therapist: Hello! How can I help you today?
You: I am feeling sad today.
Therapist: How long have you been feeling sad today?
You: I need some help with my project.
Therapist: Are you sure you need some help with your project?
You: My mother is not happy with my work.
Therapist: Tell me more about your mother.
You: quit
Therapist: Goodbye. It was nice talking to you.</code></pre>
                    </div>

                    <p class="mb-6">
                        通过上述的编程实践，我们可以直观地总结出规则驱动系统的根本局限性，这些局限正是对符号主义理论挑战的直接印证：
                    </p>
                    <ul class="list-disc pl-6 mb-6 space-y-2">
                        <li><strong>缺乏语义理解</strong>：系统不理解词义。例如，面对"I am <strong>not</strong> happy"的输入，它仍会机械地匹配规则并生成语义不通的回应，因为它无法理解否定词"not"的作用。</li>
                        <li><strong>无上下文记忆</strong>：系统是<strong>无状态的（Stateless）</strong>，每次回应仅基于当前单句输入，无法进行连贯的多轮对话。</li>
                        <li><strong>规则的扩展性问题</strong>：尝试增加更多规则会导致规则库的规模爆炸式增长，规则间的冲突与优先级管理将变得极其复杂，最终导致系统难以维护。</li>
                    </ul>

                    <p class="mb-6">
                        然而，尽管存在这些显而易见的缺陷，ELIZA在当时却产生了著名的<span class="highlight-text">"ELIZA效应"</span>，许多用户相信它能理解自己。这种智能的幻觉主要源于其巧妙的对话策略（如扮演被动的提问者、使用开放式模板）以及人类天生的情感投射心理。
                    </p>

                    <p class="mb-6">
                        ELIZA的实践清晰地揭示了符号主义方法的核心矛盾：系统看似智能的表现，完全依赖于设计者预先编码的规则。然而，面对真实世界语言的无限可能性，这种穷举式的方法注定不可扩展。系统没有真正的理解，只是在执行符号操作，这正是其脆弱性的根源。
                    </p>
                </section>
            </section>

            <!-- 2.3 马文·明斯基的心智社会 -->
            <section id="society-of-mind" class="mb-12">
                <h2>2.3 马文·明斯基的心智社会</h2>
                <p class="mb-6">
                    符号主义的探索和ELIZA的实践，共同指向了一个问题：通过预设规则构建的、单一的、集中的推理引擎，似乎难以通向真正的智能。无论规则库多么庞大，系统在面对真实世界的模糊性、复杂性和无穷变化时，总是显得僵化而脆弱。这一困境促使一些顶尖的思考者开始反思人工智能最底层的设计哲学。
                </p>
                <p class="mb-6">
                    其中，<strong>马文·明斯基（Marvin Minsky）</strong>没有继续尝试为单一推理核心添加更多规则，而是在他的<strong>《心智社会》（The Society of Mind）</strong>一书中提出了一个革命性的问题：
                </p>
                <div class="quote-block">
                    "What magical trick makes us intelligent? The trick is that there is no trick. The power of intelligence stems from our vast diversity, not from any single, perfect principle."
                </div>

                <!-- 2.3.1 对单一整体智能模型的反思 -->
                <section id="single-intelligence" class="mb-10">
                    <h3>2.3.1 对单一整体智能模型的反思</h3>
                    <p class="mb-6">
                        20世纪70至80年代，符号主义的局限性日益明显。专家系统虽然在高度垂直的领域取得了成功，但它们无法拥有儿童般的常识；SHRDLU虽然能在一个封闭的积木世界中表现出色，但它无法理解这个世界之外的任何事情；ELIZA虽然能模仿对话，但它对对话内容本身一无所知。
                    </p>
                    <p class="mb-6">
                        这些系统都遵循着一种<span class="highlight-text">自上而下（Top-down）</span>的设计思路：一个全知全能的中央处理器，根据一套统一的逻辑规则来处理信息和做出决策。
                    </p>
                    <p class="mb-6">
                        面对这种普遍的失败，明斯基开始提出一系列根本性的问题：
                    </p>
                    <ul class="list-disc pl-6 mb-6 space-y-2">
                        <li><strong>"理解"是什么？</strong> 当我们说我们理解一个故事时，这是一种单一的能力吗？还是说，它其实是视觉化能力、逻辑推理能力、情感共鸣能力、社会关系常识等数十种不同心智过程协同工作的结果？</li>
                        <li><strong>"常识"是什么？</strong> 常识是一个包含了数百万条逻辑规则的庞大知识库吗（如Cyc项目的尝试）？还是说，它是一种分布式的、由无数具体经验和简单规则片段交织而成的网络？</li>
                        <li><strong>智能体应该如何构建？</strong> 我们是否应该继续追求一个完美的、统一的逻辑系统，还是应该承认，智能本身就是"不完美"的、由许多功能各异、甚至会彼此冲突的简单部分组成的大杂烩？</li>
                    </ul>
                    <p class="mb-6">
                        这些问题直指单一整体智能模型的核心弊端。该类模型试图用一种统一的表示和推理机制来解决所有问题，但这与我们观察到的自然智能（尤其是人类智能）的运作方式相去甚远。明斯基认为，强行将多样化的心智活动塞进一个僵化的逻辑框架中，正是导致早期人工智能研究停滞不前的根源。
                    </p>
                    <p class="mb-6">
                        正是基于这样的反思，明斯基提出了一个颠覆性的构想，他不再将心智视为一个金字塔式的层级结构，而是将其看作一个扁平化的、充满了互动与协作的"社会"。
                    </p>
                </section>

                <!-- 2.3.2 作为协作体的智能 -->
                <section id="collaborative-intelligence" class="mb-10">
                    <h3>2.3.2 作为协作体的智能</h3>
                    <p class="mb-6">
                        在明斯基的理论框架中，智能体的定义与我们第一章讨论的现代智能体有所不同。这里的智能体指的是一个极其简单的、专门化的心智过程，它自身是"无心"的。例如，一个负责识别线条的<code>LINE-FINDER</code>智能体，或一个负责抓握的<code>GRASP</code>智能体。
                    </p>
                    <p class="mb-6">
                        这些简单的智能体被组织起来，形成功能更强大的<span class="highlight-text">机构（Agency）</span>。一个机构是一组协同工作的智能体，旨在完成一个更复杂的任务。例如，一个负责搭积木的<code>BUILD</code>机构，可能由<code>SEE</code>、<code>FIND</code>、<code>GET</code>、<code>PUT</code>等多个下层智能体或机构组成。它们之间通过去中心化的激活与抑制信号相互影响，形成动态的控制流。
                    </p>
                    <p class="mb-6">
                        <span class="highlight-text">涌现（Emergence）</span>是理解心智社会理论的关键。复杂的、有目的性的智能行为，并非由某个高级智能体预先规划，而是从大量简单的底层智能体之间的局部交互中自发产生的。
                    </p>
                    <p class="mb-6">
                        让我们以经典的"搭建积木塔"任务为例，来说明这一过程，如图2.6所示。当一个高层目标（如"我要搭一个塔"）出现时，它会激活一个名为<code>BUILD-TOWER</code>的高层机构。
                    </p>
                    <div class="image-container">
                        <img src="../docs/images/2-figures/1757246501849-4.png" alt="心智社会中搭建积木塔行为的涌现机制示意图" />
                        <p class="image-caption">图 2.6 "心智社会"中搭建积木塔行为的涌现机制示意图</p>
                    </div>
                    <ol class="list-decimal pl-6 mb-6 space-y-2">
                        <li><code>BUILD-TOWER</code>机构并不知道如何执行具体的物理动作，它的唯一作用是激活它的下属机构，比如<code>BUILDER</code>。</li>
                        <li><code>BUILDER</code>机构同样很简单，它可能只包含一个循环逻辑：只要塔还没搭完，就激活<code>ADD-BLOCK</code>机构。</li>
                        <li><code>ADD-BLOCK</code>机构则负责协调更具体的子任务，它会依次激活<code>FIND-BLOCK</code>、<code>GET-BLOCK</code>和<code>PUT-ON-TOP</code>这三个子机构。</li>
                        <li>每一个子机构又由更底层的智能体构成。例如，<code>GET-BLOCK</code>机构会激活视觉系统中的<code>SEE-SHAPE</code>智能体、运动系统中的<code>REACH</code>和<code>GRASP</code>智能体。</li>
                    </ol>
                    <p class="mb-6">
                        在这个过程中，没有任何一个智能体或机构拥有整个任务的全局规划。<code>GRASP</code>只负责抓握，它不知道什么是塔；<code>BUILDER</code>只负责循环，它不知道如何控制手臂。然而，当这个由无数"无心"的智能体组成的社会，通过简单的激活和抑制规则相互作用时，一个看似高度智能的行为——搭建积木塔，就自然而然地涌现了出来。
                    </p>
                </section>

                <!-- 2.3.3 对多智能体系统的理论启发 -->
                <section id="multi-agent-inspiration" class="mb-10">
                    <h3>2.3.3 对多智能体系统的理论启发</h3>
                    <p class="mb-6">
                        心智社会理论最深远的影响，在于它为<span class="highlight-text">分布式人工智能（Distributed Artificial Intelligence, DAI）</span>以及后来的<span class="highlight-text">多智能体系统（Multi-Agent System, MAS）</span>提供了重要的概念基础。它引出研究者们的思考：
                    </p>
                    <div class="quote-block">
                        如果一个心智内部的智能，是通过大量简单智能体的协作而涌现的，那么，在多个独立的、物理上分离的计算实体（计算机、机器人）之间，是否也能通过协作涌现出更强大的"群体智能"？
                    </div>
                    <p class="mb-6">
                        这个问题的提出，直接将研究焦点从"如何构建一个全能的单一智能体"转向了"如何设计一个高效协作的智能体群体"。具体而言，心智社会在以下几个方面直接启发了多智能体系统的研究：
                    </p>
                    <ul class="list-disc pl-6 mb-6 space-y-2">
                        <li><strong>去中心化控制（Decentralized Control）</strong>：理论的核心在于不存在中央控制器。这一思想被MAS领域完全继承，如何设计没有中心节点的协调机制和任务分配策略，成为了MAS的核心研究课题之一。</li>
                        <li><strong>涌现式计算（Emergent Computation）</strong>：复杂问题的解决方案可以从简单的局部交互规则中自发产生。这启发了MAS中大量基于涌现思想的算法，如蚁群算法、粒子群优化等，用于解决复杂的优化和搜索问题。</li>
                        <li><strong>智能体的社会性（Agent Sociality）</strong>：明斯基的理论强调了智能体之间的交互（激活、抑制）。MAS领域将其进一步扩展，系统地研究智能体之间的通信语言（如ACL）、交互协议（如契约网）、协商策略、信任模型乃至组织结构，从而构建起真正的计算社会。</li>
                        <li><strong>异构性与专门化（Heterogeneity and Specialization）</strong>：心智社会中的每个智能体都有特定的功能，这启发了MAS中异构智能体的设计思想。不同的智能体可以有不同的能力、知识和推理机制，通过分工合作来解决复杂问题。</li>
                    </ul>
                    <p class="mb-6">
                        然而，心智社会理论也面临着实现上的挑战。如何设计有效的激活和抑制机制？如何避免智能体之间的冲突导致系统陷入混乱？如何确保涌现出的行为是有意义和可控的？这些问题至今仍是多智能体系统研究的核心议题。
                    </p>
                    <p class="mb-6">
                        尽管如此，明斯基的心智社会理论为我们提供了一个全新的视角来理解智能的本质。它告诉我们，智能不是一个单一的、完美的算法，而是一个复杂的、动态的、充满矛盾和协作的社会过程。这一洞察不仅深刻影响了人工智能的理论发展，也为现代多智能体系统和分布式AI的实践提供了重要的指导思想。
                    </p>
                    
                    <div class="image-container">
                        <img src="../docs/images/2-figures/1757246501849-6.png" alt="从单一智能体到多智能体系统的演进" />
                        <p class="image-caption">图 2.7 从单一智能体到多智能体系统的演进</p>
                    </div>
                </section>
            </section>

            <!-- 2.4 学习范式的演进与现代智能体 -->
            <section id="learning-paradigm" class="mb-12">
                <h2>2.4 学习范式的演进与现代智能体</h2>
                <p class="mb-6">
                    符号主义的探索和明斯基的心智社会理论，共同揭示了一个重要问题：仅仅依靠预编程的规则和符号操作，很难构建出真正智能的系统。真正的智能需要<span class="highlight-text">学习能力</span>——从经验中获取知识、适应新环境、改进性能的能力。
                </p>
                <p class="mb-6">
                    从20世纪80年代开始，人工智能领域经历了一系列学习范式的变革，每一次变革都深刻影响了智能体的设计思路。让我们追溯这一演进历程，理解现代智能体技术的理论根基。
                </p>

                <!-- 2.4.1 从符号到联结 -->
                <section id="connectionism" class="mb-10">
                    <h3>2.4.1 从符号到联结</h3>
                    <p class="mb-6">
                        20世纪80年代中期，<span class="highlight-text">联结主义（Connectionism）</span>的兴起标志着AI研究范式的重大转变。与符号主义试图模拟高层认知过程不同，联结主义从大脑的神经网络结构中寻找灵感，认为智能来源于大量简单处理单元（神经元）之间的连接和交互。
                </p>
                    <p class="mb-6">
                        这一转变的理论基础是<strong>分布式表示（Distributed Representation）</strong>的概念。在符号系统中，一个概念（如"猫"）通常用一个离散的符号来表示。而在联结主义系统中，"猫"这个概念是通过网络中多个神经元的激活模式来表示的——没有单一的"猫神经元"，而是一个分布式的激活模式对应着"猫"的概念。
                    </p>
                    <p class="mb-6">
                        联结主义的核心优势在于其<span class="highlight-text">学习能力</span>。通过调整神经元之间连接的权重，网络可以从数据中学习模式，而不需要人工编程规则。1986年，Rumelhart等人重新发现并推广了<strong>反向传播算法</strong>，使得多层神经网络的训练成为可能，这直接推动了联结主义的复兴。
                    </p>
                    <p class="mb-6">
                        然而，早期的神经网络也面临着严重的限制：
                    </p>
                    <ul class="list-disc pl-6 mb-6 space-y-2">
                        <li><strong>计算资源限制</strong>：训练大型网络需要巨大的计算资源，当时的硬件条件无法支撑</li>
                        <li><strong>数据稀缺</strong>：缺乏大规模的标注数据集来训练复杂模型</li>
                        <li><strong>理论不完善</strong>：对深层网络的训练机制和表示能力缺乏深入理解</li>
                    </ul>
                    <p class="mb-6">
                        这些限制导致了20世纪90年代的"AI寒冬"，研究重心转向了其他方向。
                    </p>
                </section>

                <!-- 2.4.2 基于强化学习的智能体 -->
                <section id="reinforcement-learning" class="mb-10">
                    <h3>2.4.2 基于强化学习的智能体</h3>
                    <p class="mb-6">
                        在联结主义遭遇挫折的同时，另一个重要的学习范式悄然兴起——<span class="highlight-text">强化学习（Reinforcement Learning, RL）</span>。与监督学习需要大量标注数据不同，强化学习通过与环境的交互来学习，这更接近生物学习的本质。
                    </p>
                    <p class="mb-6">
                        强化学习的核心思想可以用<strong>马尔可夫决策过程（MDP）</strong>来描述：
                    </p>
                    <ul class="list-disc pl-6 mb-6 space-y-2">
                        <li><strong>状态（State）</strong>：智能体对环境的观察</li>
                        <li><strong>动作（Action）</strong>：智能体可以执行的行为</li>
                        <li><strong>奖励（Reward）</strong>：环境对智能体行为的反馈</li>
                        <li><strong>策略（Policy）</strong>：智能体选择动作的规则</li>
                    </ul>
                    <p class="mb-6">
                        智能体的目标是学习一个最优策略，使得长期累积奖励最大化。这种学习方式不需要明确的"正确答案"，而是通过试错和奖励信号来改进行为。
                    </p>
                    <p class="mb-6">
                        强化学习在智能体设计中的重要性体现在以下几个方面：
                    </p>
                    <ul class="list-disc pl-6 mb-6 space-y-2">
                        <li><strong>自主学习</strong>：智能体可以在没有人类监督的情况下改进性能</li>
                        <li><strong>适应性</strong>：能够适应动态变化的环境</li>
                        <li><strong>目标导向</strong>：通过奖励机制明确学习目标</li>
                        <li><strong>序列决策</strong>：考虑行为的长期后果，而不仅仅是即时效果</li>
                    </ul>
                    <p class="mb-6">
                        经典的强化学习算法包括Q-learning、SARSA、Actor-Critic等。这些算法在游戏、机器人控制、资源分配等领域取得了显著成功。
                    </p>
                    
                    <div class="image-container">
                        <img src="../docs/images/2-figures/1757246501849-7.png" alt="强化学习的基本循环" />
                        <p class="image-caption">图 2.8 强化学习的基本循环：智能体与环境的交互</p>
                    </div>
                </section>

                <!-- 2.4.3 基于大规模数据的预训练 -->
                <section id="pretraining" class="mb-10">
                    <h3>2.4.3 基于大规模数据的预训练</h3>
                    <p class="mb-6">
                        进入21世纪后，三个关键因素的汇聚重新点燃了深度学习的火焰：<strong>大数据</strong>、<strong>强大的计算资源</strong>（特别是GPU）、以及<strong>改进的算法</strong>。这导致了一个新的学习范式的出现：<span class="highlight-text">预训练-微调（Pre-training & Fine-tuning）</span>。
                    </p>
                    <p class="mb-6">
                        这一范式的核心思想是：首先在大规模无标注数据上进行<strong>自监督预训练</strong>，学习通用的表示和知识，然后在特定任务的小规模标注数据上进行<strong>微调</strong>，适应具体应用。
                    </p>
                    <p class="mb-6">
                        预训练-微调范式的发展经历了几个重要阶段：
                    </p>

                    <h4 class="text-lg font-semibold mb-4 text-gray-700 dark:text-gray-300">计算机视觉领域的突破</h4>
                    <p class="mb-6">
                        2012年，AlexNet在ImageNet竞赛中的胜利标志着深度学习时代的到来。研究者发现，在ImageNet这样的大规模数据集上预训练的卷积神经网络，学到的特征表示具有很强的通用性，可以通过微调应用到其他视觉任务上。
                    </p>

                    <h4 class="text-lg font-semibold mb-4 text-gray-700 dark:text-gray-300">自然语言处理的革命</h4>
                    <p class="mb-6">
                        2018年，BERT（Bidirectional Encoder Representations from Transformers）的出现彻底改变了NLP领域。BERT通过在大规模文本语料上进行掩码语言模型预训练，学习了丰富的语言表示，然后可以通过简单的微调在各种NLP任务上取得最佳性能。
                    </p>

                    <h4 class="text-lg font-semibold mb-4 text-gray-700 dark:text-gray-300">大语言模型的涌现</h4>
                    <p class="mb-6">
                        随着模型规模的不断增大，研究者发现了一个令人惊讶的现象：当模型参数达到一定规模时，会出现<span class="highlight-text">涌现能力（Emergent Abilities）</span>——模型展现出训练时未明确优化的新能力。
                    </p>
                    <p class="mb-6">
                        GPT系列模型的发展完美诠释了这一现象：
                    </p>
                    <ul class="list-disc pl-6 mb-6 space-y-2">
                        <li><strong>GPT-1（2018）</strong>：1.17亿参数，展示了无监督预训练的潜力</li>
                        <li><strong>GPT-2（2019）</strong>：15亿参数，展现了令人印象深刻的文本生成能力</li>
                        <li><strong>GPT-3（2020）</strong>：1750亿参数，展现了少样本学习和上下文学习能力</li>
                        <li><strong>GPT-4（2023）</strong>：参数规模未公开，展现了多模态理解和复杂推理能力</li>
                    </ul>
                </section>

                <!-- 2.4.4 基于大语言模型的智能体 -->
                <section id="llm-agents" class="mb-10">
                    <h3>2.4.4 基于大语言模型的智能体</h3>
                    <p class="mb-6">
                        大语言模型的涌现能力为智能体设计带来了革命性的变化。与传统的基于规则或强化学习的智能体不同，<span class="highlight-text">基于LLM的智能体</span>具有以下独特优势：
                    </p>

                    <h4 class="text-lg font-semibold mb-4 text-gray-700 dark:text-gray-300">上下文学习（In-Context Learning）</h4>
                    <p class="mb-6">
                        LLM可以在推理时通过上下文示例学习新任务，无需重新训练。这使得智能体可以快速适应新的场景和需求。
                    </p>

                    <h4 class="text-lg font-semibold mb-4 text-gray-700 dark:text-gray-300">思维链推理（Chain-of-Thought Reasoning）</h4>
                    <p class="mb-6">
                        通过引导LLM逐步分解复杂问题，可以显著提升其推理能力。这为构建能够处理复杂任务的智能体提供了新的可能。
                    </p>

                    <h4 class="text-lg font-semibold mb-4 text-gray-700 dark:text-gray-300">工具使用能力</h4>
                    <p class="mb-6">
                        现代LLM展现出了使用外部工具的能力，如调用API、执行代码、搜索信息等。这使得智能体的能力边界大大扩展。
                    </p>

                    <p class="mb-6">
                        基于LLM的智能体通常采用以下架构：
                    </p>
                    <div class="image-container">
                        <img src="../docs/images/2-figures/1757246501849-5.png" alt="基于LLM的智能体架构" />
                        <p class="image-caption">图 2.7 基于LLM的智能体架构：感知-思考-行动-观察循环</p>
                    </div>
                    <ol class="list-decimal pl-6 mb-6 space-y-2">
                        <li><strong>感知（Perception）</strong>：接收和处理来自环境的信息</li>
                        <li><strong>思考（Thought）</strong>：基于当前状态和历史经验进行推理</li>
                        <li><strong>行动（Action）</strong>：选择并执行适当的动作</li>
                        <li><strong>观察（Observation）</strong>：获取行动结果的反馈</li>
                    </ol>
                    <p class="mb-6">
                        这种架构实现了从被动的问答系统到主动的智能体的转变，为构建真正自主的AI系统奠定了基础。
                    </p>
                </section>

                <!-- 2.4.5 智能体发展关键节点概览 -->
                <section id="timeline" class="mb-10">
                    <h3>2.4.5 智能体发展关键节点概览</h3>
                    <p class="mb-6">
                        为了更好地理解智能体发展的历史脉络，让我们通过时间线的方式回顾关键的里程碑事件：
                    </p>
                    <div class="timeline">
                        <div class="timeline-item">
                            <h4 class="font-semibold text-lg mb-2">1950s-1960s：符号主义奠基</h4>
                            <p class="text-gray-600 dark:text-gray-300">
                                • 1956年达特茅斯会议，人工智能正式诞生<br>
                                • 物理符号系统假设提出<br>
                                • 早期专家系统概念形成
                            </p>
                        </div>
                        <div class="timeline-item">
                            <h4 class="font-semibold text-lg mb-2">1960s-1970s：早期智能体探索</h4>
                            <p class="text-gray-600 dark:text-gray-300">
                                • 1966年ELIZA发布，展示对话系统可能性<br>
                                • 1970年SHRDLU展现理解与行动结合<br>
                                • 专家系统如MYCIN取得实际应用成功
                            </p>
                        </div>
                        <div class="timeline-item">
                            <h4 class="font-semibold text-lg mb-2">1980s：范式转换期</h4>
                            <p class="text-gray-600 dark:text-gray-300">
                                • 1986年《心智社会》出版，提出分布式智能理论<br>
                                • 反向传播算法推广，联结主义复兴<br>
                                • 强化学习理论体系逐步完善
                            </p>
                        </div>
                        <div class="timeline-item">
                            <h4 class="font-semibold text-lg mb-2">1990s-2000s：多元化发展</h4>
                            <p class="text-gray-600 dark:text-gray-300">
                                • 多智能体系统研究兴起<br>
                                • 强化学习在游戏和控制领域取得突破<br>
                                • 互联网普及为数据收集提供新机遇
                            </p>
                        </div>
                        <div class="timeline-item">
                            <h4 class="font-semibold text-lg mb-2">2010s：深度学习革命</h4>
                            <p class="text-gray-600 dark:text-gray-300">
                                • 2012年AlexNet引发深度学习热潮<br>
                                • 2016年AlphaGo击败人类围棋冠军<br>
                                • 2018年BERT革新自然语言处理
                            </p>
                        </div>
                        <div class="timeline-item">
                            <h4 class="font-semibold text-lg mb-2">2020s：大模型时代</h4>
                            <p class="text-gray-600 dark:text-gray-300">
                                • 2020年GPT-3展现涌现能力<br>
                                • 2022年ChatGPT引发AI应用热潮<br>
                                • 基于LLM的智能体成为研究热点
                            </p>
                        </div>
                    </div>
                    
                    <div class="image-container">
                        <img src="../docs/images/2-figures/1757246501849-8.png" alt="智能体发展的历史时间线" />
                        <p class="image-caption">图 2.9 智能体发展的历史时间线：从符号主义到大模型时代</p>
                    </div>
                </section>
            </section>

            <!-- 2.5 本章小结 -->
            <section id="summary" class="mb-12">
                <h2>2.5 本章小结</h2>
                <p class="mb-6">
                    通过回顾智能体发展的历史脉络，我们可以清晰地看到人工智能领域思想演进的轨迹。从符号主义的理性探索，到联结主义的生物启发，再到现代大语言模型的涌现智能，每一次范式转换都深刻影响着智能体的设计理念和技术实现。
                </p>
                <p class="mb-6">
                    <strong>符号主义时期</strong>的贡献在于建立了人工智能的理论基础，提出了用计算机模拟人类智能的可能性。ELIZA和SHRDLU等早期系统展示了规则驱动方法的潜力，但也暴露了其在处理真实世界复杂性方面的根本局限。
                </p>
                <p class="mb-6">
                    <strong>明斯基的心智社会理论</strong>为我们提供了理解智能本质的新视角。它告诉我们，智能不是单一的、完美的算法，而是多个简单组件协作涌现的结果。这一思想直接启发了后来的多智能体系统研究，为分布式人工智能奠定了理论基础。
                </p>
                <p class="mb-6">
                    <strong>学习范式的演进</strong>展现了从规则驱动到数据驱动的转变。联结主义重新发现了神经网络的价值，强化学习提供了自主学习的框架，而预训练-微调范式则充分利用了大数据时代的优势。
                </p>
                <p class="mb-6">
                    <strong>现代大语言模型</strong>的出现标志着智能体技术的新纪元。基于LLM的智能体不仅具备了强大的语言理解和生成能力，还展现出了上下文学习、工具使用、复杂推理等涌现能力，为构建真正自主的AI系统开辟了新的道路。
                </p>
                <div class="quote-block">
                    历史告诉我们，智能体技术的发展不是线性的进步，而是螺旋式的上升。每一次看似的"失败"都为后续的突破积累了宝贵的经验和洞察。理解这一历史进程，不仅有助于我们把握当前技术的本质和局限，更能启发我们思考未来智能体发展的可能方向。
                </div>
                <p class="mb-6">
                    在下一章中，我们将深入探讨现代智能体的核心技术组件，了解如何将历史积淀的理论智慧转化为实际可用的技术系统。
                </p>
                
                <div class="image-container">
                    <img src="../docs/images/2-figures/1757246501849-9.png" alt="智能体技术发展的核心里程碑" />
                    <p class="image-caption">图 2.10 智能体技术发展的核心里程碑：从理论到实践的演进</p>
                </div>

                <!-- 参考文献 -->
                <h3 class="text-xl font-semibold mb-4 mt-8">参考文献</h3>
                <div class="text-sm text-gray-600 dark:text-gray-400 space-y-2">
                    <p>1. Newell, A., & Simon, H. A. (1976). Computer science as empirical inquiry: Symbols and search. Communications of the ACM, 19(3), 113-126.</p>
                    <p>2. Weizenbaum, J. (1966). ELIZA—a computer program for the study of natural language communication between man and machine. Communications of the ACM, 9(1), 36-45.</p>
                    <p>3. Winograd, T. (1972). Understanding natural language. Cognitive psychology, 3(1), 1-191.</p>
                    <p>4. Minsky, M. (1986). The society of mind. Simon and Schuster.</p>
                    <p>5. Rumelhart, D. E., Hinton, G. E., & Williams, R. J. (1986). Learning representations by back-propagating errors. Nature, 323(6088), 533-536.</p>
                    <p>6. Sutton, R. S., & Barto, A. G. (2018). Reinforcement learning: An introduction. MIT press.</p>
                    <p>7. Vaswani, A., et al. (2017). Attention is all you need. Advances in neural information processing systems, 30.</p>
                    <p>8. Brown, T., et al. (2020). Language models are few-shot learners. Advances in neural information processing systems, 33, 1877-1901.</p>
                    <p>9. Wei, J., et al. (2022). Chain-of-thought prompting elicits reasoning in large language models. Advances in Neural Information Processing Systems, 35, 24824-24837.</p>
                    <p>10. Yao, S., et al. (2022). ReAct: Synergizing reasoning and acting in language models. arXiv preprint arXiv:2210.03629.</p>
                </div>
            </section>
        </article>
    </main>

    <script>
        // 主题切换功能
        const themeToggle = document.getElementById('theme-toggle');
        const html = document.documentElement;
        
        // 检查系统主题偏好
        const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        const savedTheme = localStorage.getItem('theme');
        
        if (savedTheme) {
            html.classList.toggle('dark', savedTheme === 'dark');
        } else {
            html.classList.toggle('dark', prefersDark);
        }
        
        themeToggle.addEventListener('click', () => {
            html.classList.toggle('dark');
            localStorage.setItem('theme', html.classList.contains('dark') ? 'dark' : 'light');
        });

        // 页面加载动画
        window.addEventListener('load', () => {
            document.querySelectorAll('.fade-in').forEach((el, index) => {
                setTimeout(() => {
                    el.style.opacity = '1';
                    el.style.transform = 'translateY(0)';
                }, index * 100);
            });
        });

        // 返回顶部按钮
        const backToTop = document.getElementById('backToTop');
        
        window.addEventListener('scroll', () => {
            if (window.pageYOffset > 300) {
                backToTop.classList.add('show');
            } else {
                backToTop.classList.remove('show');
            }
        });
        
        backToTop.addEventListener('click', () => {
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        });

        // 平滑滚动到锚点
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {
                    target.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            });
        });

        // 代码块复制功能
        document.querySelectorAll('.code-block').forEach(block => {
            const button = document.createElement('button');
            button.className = 'absolute top-2 right-2 px-2 py-1 text-xs bg-gray-200 dark:bg-gray-700 rounded hover:bg-gray-300 dark:hover:bg-gray-600 transition-colors';
            button.textContent = '复制';
            button.style.position = 'absolute';
            button.style.top = '0.5rem';
            button.style.right = '0.5rem';
            
            block.style.position = 'relative';
            block.appendChild(button);
            
            button.addEventListener('click', () => {
                const code = block.querySelector('pre code') || block.querySelector('pre');
                navigator.clipboard.writeText(code.textContent).then(() => {
                    button.textContent = '已复制';
                    setTimeout(() => {
                        button.textContent = '复制';
                    }, 2000);
                });
            });
        });
    </script>
</body>
</html>